// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: ltsrpc.proto

package ltsrpc

import (
	context "context"
	fmt "fmt"
	io "io"
	math "math"

	proto "github.com/gogo/protobuf/proto"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

// Common
type StatusCode int32

const (
	StatusCode_SC_OK                 StatusCode = 0
	StatusCode_SC_ERROR              StatusCode = 1
	StatusCode_SC_UNKNOWN            StatusCode = 2
	StatusCode_SC_NOT_LEADER         StatusCode = 3
	StatusCode_SC_NOT_EXISTS         StatusCode = 4
	StatusCode_SC_CANCEL             StatusCode = 5
	StatusCode_SC_RESOURCE_EXHAUSTED StatusCode = 6
	StatusCode_SC_ABORTED            StatusCode = 7
	StatusCode_SC_LEADER_NOT_FOUND   StatusCode = 8
)

var StatusCode_name = map[int32]string{
	0: "SC_OK",
	1: "SC_ERROR",
	2: "SC_UNKNOWN",
	3: "SC_NOT_LEADER",
	4: "SC_NOT_EXISTS",
	5: "SC_CANCEL",
	6: "SC_RESOURCE_EXHAUSTED",
	7: "SC_ABORTED",
	8: "SC_LEADER_NOT_FOUND",
}

var StatusCode_value = map[string]int32{
	"SC_OK":                 0,
	"SC_ERROR":              1,
	"SC_UNKNOWN":            2,
	"SC_NOT_LEADER":         3,
	"SC_NOT_EXISTS":         4,
	"SC_CANCEL":             5,
	"SC_RESOURCE_EXHAUSTED": 6,
	"SC_ABORTED":            7,
	"SC_LEADER_NOT_FOUND":   8,
}

func (x StatusCode) String() string {
	return proto.EnumName(StatusCode_name, int32(x))
}

func (StatusCode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_5ac4e4fed84a8688, []int{0}
}

type Cluster struct {
	ClusterId uint32 `protobuf:"varint,1,opt,name=cluster_id,json=clusterId,proto3" json:"cluster_id,omitempty"`
}

func (m *Cluster) Reset()         { *m = Cluster{} }
func (m *Cluster) String() string { return proto.CompactTextString(m) }
func (*Cluster) ProtoMessage()    {}
func (*Cluster) Descriptor() ([]byte, []int) {
	return fileDescriptor_5ac4e4fed84a8688, []int{0}
}
func (m *Cluster) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Cluster) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Cluster.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Cluster) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Cluster.Merge(m, src)
}
func (m *Cluster) XXX_Size() int {
	return m.Size()
}
func (m *Cluster) XXX_DiscardUnknown() {
	xxx_messageInfo_Cluster.DiscardUnknown(m)
}

var xxx_messageInfo_Cluster proto.InternalMessageInfo

func (m *Cluster) GetClusterId() uint32 {
	if m != nil {
		return m.ClusterId
	}
	return 0
}

// Code and description
type Status struct {
	Code StatusCode `protobuf:"varint,1,opt,name=code,proto3,enum=ltsrpc.StatusCode" json:"code,omitempty"`
	Msg  string     `protobuf:"bytes,2,opt,name=msg,proto3" json:"msg,omitempty"`
}

func (m *Status) Reset()         { *m = Status{} }
func (m *Status) String() string { return proto.CompactTextString(m) }
func (*Status) ProtoMessage()    {}
func (*Status) Descriptor() ([]byte, []int) {
	return fileDescriptor_5ac4e4fed84a8688, []int{1}
}
func (m *Status) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Status) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Status.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Status) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Status.Merge(m, src)
}
func (m *Status) XXX_Size() int {
	return m.Size()
}
func (m *Status) XXX_DiscardUnknown() {
	xxx_messageInfo_Status.DiscardUnknown(m)
}

var xxx_messageInfo_Status proto.InternalMessageInfo

func (m *Status) GetCode() StatusCode {
	if m != nil {
		return m.Code
	}
	return StatusCode_SC_OK
}

func (m *Status) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

// Cluster member information
type Member struct {
	MemberId       uint64   `protobuf:"varint,1,opt,name=member_id,json=memberId,proto3" json:"member_id,omitempty"`
	Name           string   `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	PeerUrls       []string `protobuf:"bytes,3,rep,name=peer_urls,json=peerUrls,proto3" json:"peer_urls,omitempty"`
	ClientUrls     []string `protobuf:"bytes,4,rep,name=client_urls,json=clientUrls,proto3" json:"client_urls,omitempty"`
	LeaderPriority int32    `protobuf:"varint,5,opt,name=leader_priority,json=leaderPriority,proto3" json:"leader_priority,omitempty"`
}

func (m *Member) Reset()         { *m = Member{} }
func (m *Member) String() string { return proto.CompactTextString(m) }
func (*Member) ProtoMessage()    {}
func (*Member) Descriptor() ([]byte, []int) {
	return fileDescriptor_5ac4e4fed84a8688, []int{2}
}
func (m *Member) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Member) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Member.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Member) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Member.Merge(m, src)
}
func (m *Member) XXX_Size() int {
	return m.Size()
}
func (m *Member) XXX_DiscardUnknown() {
	xxx_messageInfo_Member.DiscardUnknown(m)
}

var xxx_messageInfo_Member proto.InternalMessageInfo

func (m *Member) GetMemberId() uint64 {
	if m != nil {
		return m.MemberId
	}
	return 0
}

func (m *Member) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Member) GetPeerUrls() []string {
	if m != nil {
		return m.PeerUrls
	}
	return nil
}

func (m *Member) GetClientUrls() []string {
	if m != nil {
		return m.ClientUrls
	}
	return nil
}

func (m *Member) GetLeaderPriority() int32 {
	if m != nil {
		return m.LeaderPriority
	}
	return 0
}

type RequestHeader struct {
	ClusterId uint32 `protobuf:"varint,1,opt,name=cluster_id,json=clusterId,proto3" json:"cluster_id,omitempty"`
}

func (m *RequestHeader) Reset()         { *m = RequestHeader{} }
func (m *RequestHeader) String() string { return proto.CompactTextString(m) }
func (*RequestHeader) ProtoMessage()    {}
func (*RequestHeader) Descriptor() ([]byte, []int) {
	return fileDescriptor_5ac4e4fed84a8688, []int{3}
}
func (m *RequestHeader) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RequestHeader) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RequestHeader.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RequestHeader) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RequestHeader.Merge(m, src)
}
func (m *RequestHeader) XXX_Size() int {
	return m.Size()
}
func (m *RequestHeader) XXX_DiscardUnknown() {
	xxx_messageInfo_RequestHeader.DiscardUnknown(m)
}

var xxx_messageInfo_RequestHeader proto.InternalMessageInfo

func (m *RequestHeader) GetClusterId() uint32 {
	if m != nil {
		return m.ClusterId
	}
	return 0
}

type ResponseHeader struct {
	ClusterId uint32  `protobuf:"varint,1,opt,name=cluster_id,json=clusterId,proto3" json:"cluster_id,omitempty"`
	Status    *Status `protobuf:"bytes,2,opt,name=status,proto3" json:"status,omitempty"`
}

func (m *ResponseHeader) Reset()         { *m = ResponseHeader{} }
func (m *ResponseHeader) String() string { return proto.CompactTextString(m) }
func (*ResponseHeader) ProtoMessage()    {}
func (*ResponseHeader) Descriptor() ([]byte, []int) {
	return fileDescriptor_5ac4e4fed84a8688, []int{4}
}
func (m *ResponseHeader) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResponseHeader) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ResponseHeader.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ResponseHeader) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResponseHeader.Merge(m, src)
}
func (m *ResponseHeader) XXX_Size() int {
	return m.Size()
}
func (m *ResponseHeader) XXX_DiscardUnknown() {
	xxx_messageInfo_ResponseHeader.DiscardUnknown(m)
}

var xxx_messageInfo_ResponseHeader proto.InternalMessageInfo

func (m *ResponseHeader) GetClusterId() uint32 {
	if m != nil {
		return m.ClusterId
	}
	return 0
}

func (m *ResponseHeader) GetStatus() *Status {
	if m != nil {
		return m.Status
	}
	return nil
}

// Cluster member RPC
type GetMembersRequest struct {
	Header *RequestHeader `protobuf:"bytes,1,opt,name=header,proto3" json:"header,omitempty"`
}

func (m *GetMembersRequest) Reset()         { *m = GetMembersRequest{} }
func (m *GetMembersRequest) String() string { return proto.CompactTextString(m) }
func (*GetMembersRequest) ProtoMessage()    {}
func (*GetMembersRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_5ac4e4fed84a8688, []int{5}
}
func (m *GetMembersRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetMembersRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetMembersRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetMembersRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetMembersRequest.Merge(m, src)
}
func (m *GetMembersRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetMembersRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetMembersRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetMembersRequest proto.InternalMessageInfo

func (m *GetMembersRequest) GetHeader() *RequestHeader {
	if m != nil {
		return m.Header
	}
	return nil
}

type GetMembersResponse struct {
	Header     *ResponseHeader `protobuf:"bytes,1,opt,name=header,proto3" json:"header,omitempty"`
	Members    []*Member       `protobuf:"bytes,2,rep,name=members,proto3" json:"members,omitempty"`
	Leader     *Member         `protobuf:"bytes,3,opt,name=leader,proto3" json:"leader,omitempty"`
	EtcdLeader *Member         `protobuf:"bytes,4,opt,name=etcd_leader,json=etcdLeader,proto3" json:"etcd_leader,omitempty"`
}

func (m *GetMembersResponse) Reset()         { *m = GetMembersResponse{} }
func (m *GetMembersResponse) String() string { return proto.CompactTextString(m) }
func (*GetMembersResponse) ProtoMessage()    {}
func (*GetMembersResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_5ac4e4fed84a8688, []int{6}
}
func (m *GetMembersResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetMembersResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetMembersResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetMembersResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetMembersResponse.Merge(m, src)
}
func (m *GetMembersResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetMembersResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetMembersResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetMembersResponse proto.InternalMessageInfo

func (m *GetMembersResponse) GetHeader() *ResponseHeader {
	if m != nil {
		return m.Header
	}
	return nil
}

func (m *GetMembersResponse) GetMembers() []*Member {
	if m != nil {
		return m.Members
	}
	return nil
}

func (m *GetMembersResponse) GetLeader() *Member {
	if m != nil {
		return m.Leader
	}
	return nil
}

func (m *GetMembersResponse) GetEtcdLeader() *Member {
	if m != nil {
		return m.EtcdLeader
	}
	return nil
}

// For txn timestamp request/response
type GetTxnTimestampCtx struct {
	TxnId uint64 `protobuf:"varint,1,opt,name=txn_id,json=txnId,proto3" json:"txn_id,omitempty"`
	TxnTs uint64 `protobuf:"varint,2,opt,name=txn_ts,json=txnTs,proto3" json:"txn_ts,omitempty"`
}

func (m *GetTxnTimestampCtx) Reset()         { *m = GetTxnTimestampCtx{} }
func (m *GetTxnTimestampCtx) String() string { return proto.CompactTextString(m) }
func (*GetTxnTimestampCtx) ProtoMessage()    {}
func (*GetTxnTimestampCtx) Descriptor() ([]byte, []int) {
	return fileDescriptor_5ac4e4fed84a8688, []int{7}
}
func (m *GetTxnTimestampCtx) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetTxnTimestampCtx) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetTxnTimestampCtx.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetTxnTimestampCtx) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetTxnTimestampCtx.Merge(m, src)
}
func (m *GetTxnTimestampCtx) XXX_Size() int {
	return m.Size()
}
func (m *GetTxnTimestampCtx) XXX_DiscardUnknown() {
	xxx_messageInfo_GetTxnTimestampCtx.DiscardUnknown(m)
}

var xxx_messageInfo_GetTxnTimestampCtx proto.InternalMessageInfo

func (m *GetTxnTimestampCtx) GetTxnId() uint64 {
	if m != nil {
		return m.TxnId
	}
	return 0
}

func (m *GetTxnTimestampCtx) GetTxnTs() uint64 {
	if m != nil {
		return m.TxnTs
	}
	return 0
}

func init() {
	proto.RegisterEnum("ltsrpc.StatusCode", StatusCode_name, StatusCode_value)
	proto.RegisterType((*Cluster)(nil), "ltsrpc.Cluster")
	proto.RegisterType((*Status)(nil), "ltsrpc.Status")
	proto.RegisterType((*Member)(nil), "ltsrpc.Member")
	proto.RegisterType((*RequestHeader)(nil), "ltsrpc.RequestHeader")
	proto.RegisterType((*ResponseHeader)(nil), "ltsrpc.ResponseHeader")
	proto.RegisterType((*GetMembersRequest)(nil), "ltsrpc.GetMembersRequest")
	proto.RegisterType((*GetMembersResponse)(nil), "ltsrpc.GetMembersResponse")
	proto.RegisterType((*GetTxnTimestampCtx)(nil), "ltsrpc.GetTxnTimestampCtx")
}

func init() { proto.RegisterFile("ltsrpc.proto", fileDescriptor_5ac4e4fed84a8688) }

var fileDescriptor_5ac4e4fed84a8688 = []byte{
	// 605 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x8c, 0x54, 0xdf, 0x6e, 0x12, 0x4f,
	0x14, 0x66, 0xbb, 0xb0, 0x85, 0x43, 0xa1, 0xdb, 0xf3, 0x4b, 0x7f, 0xd2, 0x1a, 0x91, 0xec, 0x45,
	0x25, 0x26, 0x62, 0x82, 0x4f, 0x00, 0xd3, 0xd5, 0x92, 0x22, 0x6b, 0x66, 0x96, 0xb4, 0x77, 0x1b,
	0xca, 0x4e, 0x94, 0x84, 0x7f, 0xee, 0x0c, 0x09, 0xbe, 0x85, 0xb7, 0xde, 0xf9, 0x04, 0xbe, 0x86,
	0x5e, 0xf6, 0xd2, 0x4b, 0xd3, 0xbe, 0x88, 0xd9, 0x99, 0x21, 0xfc, 0xd1, 0xa8, 0x77, 0x67, 0xbf,
	0xef, 0x3b, 0xdf, 0x9c, 0xf3, 0x71, 0x02, 0x1c, 0x8c, 0xa5, 0x48, 0xe6, 0xc3, 0xc6, 0x3c, 0x99,
	0xc9, 0x19, 0x3a, 0xfa, 0xcb, 0xab, 0xc3, 0x3e, 0x19, 0x2f, 0x84, 0xe4, 0x09, 0x3e, 0x02, 0x18,
	0xea, 0x32, 0x1a, 0xc5, 0x15, 0xab, 0x66, 0xd5, 0x4b, 0xb4, 0x60, 0x90, 0x4e, 0xec, 0xb5, 0xc1,
	0x61, 0x72, 0x20, 0x17, 0x02, 0xcf, 0x20, 0x3b, 0x9c, 0xc5, 0x5c, 0x49, 0xca, 0x4d, 0x6c, 0x18,
	0x63, 0xcd, 0x92, 0x59, 0xcc, 0xa9, 0xe2, 0xd1, 0x05, 0x7b, 0x22, 0xde, 0x56, 0xf6, 0x6a, 0x56,
	0xbd, 0x40, 0xd3, 0xd2, 0xfb, 0x6c, 0x81, 0xf3, 0x9a, 0x4f, 0x6e, 0x78, 0x82, 0x0f, 0xa1, 0x30,
	0x51, 0xd5, 0xea, 0xb1, 0x2c, 0xcd, 0x6b, 0xa0, 0x13, 0x23, 0x42, 0x76, 0x3a, 0x98, 0x70, 0xd3,
	0xaa, 0xea, 0xb4, 0x61, 0xce, 0x79, 0x12, 0x2d, 0x92, 0xb1, 0xa8, 0xd8, 0x35, 0xbb, 0x5e, 0xa0,
	0xf9, 0x14, 0xe8, 0x27, 0x63, 0x81, 0x8f, 0xa1, 0x38, 0x1c, 0x8f, 0xf8, 0x54, 0x6a, 0x3a, 0xab,
	0x68, 0xd0, 0x90, 0x12, 0x3c, 0x81, 0xc3, 0x31, 0x1f, 0xc4, 0x3c, 0x89, 0xe6, 0xc9, 0x68, 0x96,
	0x8c, 0xe4, 0x87, 0x4a, 0xae, 0x66, 0xd5, 0x73, 0xb4, 0xac, 0xe1, 0x37, 0x06, 0xf5, 0x1a, 0x50,
	0xa2, 0xfc, 0xfd, 0x82, 0x0b, 0x79, 0xa1, 0x88, 0xbf, 0xc5, 0x72, 0x05, 0x65, 0xca, 0xc5, 0x7c,
	0x36, 0x15, 0xfc, 0x9f, 0x1a, 0xf0, 0x0c, 0x1c, 0xa1, 0x92, 0x52, 0xdb, 0x15, 0x9b, 0xe5, 0xed,
	0xfc, 0xa8, 0x61, 0xbd, 0x36, 0x1c, 0xbd, 0xe2, 0x52, 0xa7, 0x25, 0xcc, 0x48, 0xf8, 0x0c, 0x9c,
	0x77, 0xea, 0x15, 0xe5, 0x5b, 0x6c, 0x1e, 0xaf, 0x9a, 0xb7, 0x66, 0xa6, 0x46, 0xe4, 0x7d, 0xb5,
	0x00, 0x37, 0x4d, 0xf4, 0x9c, 0xd8, 0xd8, 0x71, 0xf9, 0x7f, 0xed, 0xb2, 0xb9, 0xc9, 0xca, 0x06,
	0xeb, 0xb0, 0xaf, 0x7f, 0x9a, 0x74, 0x66, 0x7b, 0x73, 0x66, 0xed, 0x4c, 0x57, 0x74, 0xba, 0x9c,
	0xce, 0xb3, 0x62, 0x6f, 0x2f, 0x67, 0x84, 0x86, 0xc5, 0xe7, 0x50, 0xe4, 0x72, 0x18, 0x47, 0x46,
	0x9c, 0xfd, 0xad, 0x18, 0x52, 0x49, 0x57, 0x6f, 0xd2, 0x56, 0x8b, 0x84, 0xcb, 0x69, 0x38, 0x9a,
	0x70, 0x21, 0x07, 0x93, 0x39, 0x91, 0x4b, 0x3c, 0x06, 0x47, 0x2e, 0xa7, 0xeb, 0x0b, 0xca, 0xc9,
	0xe5, 0xb4, 0x13, 0xaf, 0x60, 0xa9, 0x23, 0xd6, 0x70, 0x28, 0x9e, 0x7e, 0xb1, 0x00, 0xd6, 0x47,
	0x8a, 0x05, 0xc8, 0x31, 0x12, 0x05, 0x97, 0x6e, 0x06, 0x0f, 0x20, 0xcf, 0x48, 0xe4, 0x53, 0x1a,
	0x50, 0xd7, 0xc2, 0x32, 0x00, 0x23, 0x51, 0xbf, 0x77, 0xd9, 0x0b, 0xae, 0x7a, 0xee, 0x1e, 0x1e,
	0x41, 0x89, 0x91, 0xa8, 0x17, 0x84, 0x51, 0xd7, 0x6f, 0x9d, 0xfb, 0xd4, 0xb5, 0x37, 0x20, 0xff,
	0xba, 0xc3, 0x42, 0xe6, 0x66, 0xb1, 0x04, 0x05, 0x46, 0x22, 0xd2, 0xea, 0x11, 0xbf, 0xeb, 0xe6,
	0xf0, 0x04, 0x8e, 0x19, 0x89, 0xa8, 0xcf, 0x82, 0x3e, 0x25, 0x7e, 0xe4, 0x5f, 0x5f, 0xb4, 0xfa,
	0x2c, 0xf4, 0xcf, 0x5d, 0xc7, 0xf8, 0xb7, 0xda, 0x01, 0x4d, 0xbf, 0xf7, 0xf1, 0x01, 0xfc, 0xc7,
	0x88, 0xf1, 0x56, 0x9e, 0x2f, 0x83, 0x7e, 0xef, 0xdc, 0xcd, 0x37, 0x3f, 0x59, 0x60, 0x77, 0x43,
	0x86, 0x97, 0x70, 0xb8, 0xb3, 0x3c, 0x9e, 0xae, 0xb2, 0xfa, 0x35, 0x95, 0xd3, 0x3f, 0x70, 0x5e,
	0x06, 0x7d, 0x80, 0xf5, 0x49, 0xe0, 0xc9, 0x86, 0x76, 0xfb, 0xd6, 0xb6, 0x6c, 0x76, 0x2e, 0xc8,
	0xcb, 0xb4, 0x2b, 0xdf, 0xee, 0xaa, 0xd6, 0xed, 0x5d, 0xd5, 0xfa, 0x71, 0x57, 0xb5, 0x3e, 0xde,
	0x57, 0x33, 0xb7, 0xf7, 0xd5, 0xcc, 0xf7, 0xfb, 0x6a, 0xe6, 0xc6, 0x51, 0xff, 0x30, 0x2f, 0x7e,
	0x06, 0x00, 0x00, 0xff, 0xff, 0xc7, 0x63, 0x38, 0xe4, 0x71, 0x04, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// LTSClient is the client API for LTS service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type LTSClient interface {
	GetTxnTimestamp(ctx context.Context, in *GetTxnTimestampCtx, opts ...grpc.CallOption) (*GetTxnTimestampCtx, error)
	GetMembers(ctx context.Context, in *GetMembersRequest, opts ...grpc.CallOption) (*GetMembersResponse, error)
}

type lTSClient struct {
	cc *grpc.ClientConn
}

func NewLTSClient(cc *grpc.ClientConn) LTSClient {
	return &lTSClient{cc}
}

func (c *lTSClient) GetTxnTimestamp(ctx context.Context, in *GetTxnTimestampCtx, opts ...grpc.CallOption) (*GetTxnTimestampCtx, error) {
	out := new(GetTxnTimestampCtx)
	err := c.cc.Invoke(ctx, "/ltsrpc.LTS/GetTxnTimestamp", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lTSClient) GetMembers(ctx context.Context, in *GetMembersRequest, opts ...grpc.CallOption) (*GetMembersResponse, error) {
	out := new(GetMembersResponse)
	err := c.cc.Invoke(ctx, "/ltsrpc.LTS/GetMembers", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// LTSServer is the server API for LTS service.
type LTSServer interface {
	GetTxnTimestamp(context.Context, *GetTxnTimestampCtx) (*GetTxnTimestampCtx, error)
	GetMembers(context.Context, *GetMembersRequest) (*GetMembersResponse, error)
}

func RegisterLTSServer(s *grpc.Server, srv LTSServer) {
	s.RegisterService(&_LTS_serviceDesc, srv)
}

func _LTS_GetTxnTimestamp_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTxnTimestampCtx)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LTSServer).GetTxnTimestamp(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ltsrpc.LTS/GetTxnTimestamp",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LTSServer).GetTxnTimestamp(ctx, req.(*GetTxnTimestampCtx))
	}
	return interceptor(ctx, in, info, handler)
}

func _LTS_GetMembers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetMembersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LTSServer).GetMembers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ltsrpc.LTS/GetMembers",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LTSServer).GetMembers(ctx, req.(*GetMembersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _LTS_serviceDesc = grpc.ServiceDesc{
	ServiceName: "ltsrpc.LTS",
	HandlerType: (*LTSServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetTxnTimestamp",
			Handler:    _LTS_GetTxnTimestamp_Handler,
		},
		{
			MethodName: "GetMembers",
			Handler:    _LTS_GetMembers_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "ltsrpc.proto",
}

func (m *Cluster) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Cluster) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ClusterId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintLtsrpc(dAtA, i, uint64(m.ClusterId))
	}
	return i, nil
}

func (m *Status) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Status) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Code != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintLtsrpc(dAtA, i, uint64(m.Code))
	}
	if len(m.Msg) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintLtsrpc(dAtA, i, uint64(len(m.Msg)))
		i += copy(dAtA[i:], m.Msg)
	}
	return i, nil
}

func (m *Member) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Member) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.MemberId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintLtsrpc(dAtA, i, uint64(m.MemberId))
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintLtsrpc(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.PeerUrls) > 0 {
		for _, s := range m.PeerUrls {
			dAtA[i] = 0x1a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.ClientUrls) > 0 {
		for _, s := range m.ClientUrls {
			dAtA[i] = 0x22
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.LeaderPriority != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintLtsrpc(dAtA, i, uint64(m.LeaderPriority))
	}
	return i, nil
}

func (m *RequestHeader) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RequestHeader) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ClusterId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintLtsrpc(dAtA, i, uint64(m.ClusterId))
	}
	return i, nil
}

func (m *ResponseHeader) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResponseHeader) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ClusterId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintLtsrpc(dAtA, i, uint64(m.ClusterId))
	}
	if m.Status != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintLtsrpc(dAtA, i, uint64(m.Status.Size()))
		n1, err1 := m.Status.MarshalTo(dAtA[i:])
		if err1 != nil {
			return 0, err1
		}
		i += n1
	}
	return i, nil
}

func (m *GetMembersRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetMembersRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Header != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintLtsrpc(dAtA, i, uint64(m.Header.Size()))
		n2, err2 := m.Header.MarshalTo(dAtA[i:])
		if err2 != nil {
			return 0, err2
		}
		i += n2
	}
	return i, nil
}

func (m *GetMembersResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetMembersResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Header != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintLtsrpc(dAtA, i, uint64(m.Header.Size()))
		n3, err3 := m.Header.MarshalTo(dAtA[i:])
		if err3 != nil {
			return 0, err3
		}
		i += n3
	}
	if len(m.Members) > 0 {
		for _, msg := range m.Members {
			dAtA[i] = 0x12
			i++
			i = encodeVarintLtsrpc(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Leader != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintLtsrpc(dAtA, i, uint64(m.Leader.Size()))
		n4, err4 := m.Leader.MarshalTo(dAtA[i:])
		if err4 != nil {
			return 0, err4
		}
		i += n4
	}
	if m.EtcdLeader != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintLtsrpc(dAtA, i, uint64(m.EtcdLeader.Size()))
		n5, err5 := m.EtcdLeader.MarshalTo(dAtA[i:])
		if err5 != nil {
			return 0, err5
		}
		i += n5
	}
	return i, nil
}

func (m *GetTxnTimestampCtx) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetTxnTimestampCtx) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TxnId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintLtsrpc(dAtA, i, uint64(m.TxnId))
	}
	if m.TxnTs != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintLtsrpc(dAtA, i, uint64(m.TxnTs))
	}
	return i, nil
}

func encodeVarintLtsrpc(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *Cluster) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ClusterId != 0 {
		n += 1 + sovLtsrpc(uint64(m.ClusterId))
	}
	return n
}

func (m *Status) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovLtsrpc(uint64(m.Code))
	}
	l = len(m.Msg)
	if l > 0 {
		n += 1 + l + sovLtsrpc(uint64(l))
	}
	return n
}

func (m *Member) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MemberId != 0 {
		n += 1 + sovLtsrpc(uint64(m.MemberId))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovLtsrpc(uint64(l))
	}
	if len(m.PeerUrls) > 0 {
		for _, s := range m.PeerUrls {
			l = len(s)
			n += 1 + l + sovLtsrpc(uint64(l))
		}
	}
	if len(m.ClientUrls) > 0 {
		for _, s := range m.ClientUrls {
			l = len(s)
			n += 1 + l + sovLtsrpc(uint64(l))
		}
	}
	if m.LeaderPriority != 0 {
		n += 1 + sovLtsrpc(uint64(m.LeaderPriority))
	}
	return n
}

func (m *RequestHeader) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ClusterId != 0 {
		n += 1 + sovLtsrpc(uint64(m.ClusterId))
	}
	return n
}

func (m *ResponseHeader) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ClusterId != 0 {
		n += 1 + sovLtsrpc(uint64(m.ClusterId))
	}
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovLtsrpc(uint64(l))
	}
	return n
}

func (m *GetMembersRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Header != nil {
		l = m.Header.Size()
		n += 1 + l + sovLtsrpc(uint64(l))
	}
	return n
}

func (m *GetMembersResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Header != nil {
		l = m.Header.Size()
		n += 1 + l + sovLtsrpc(uint64(l))
	}
	if len(m.Members) > 0 {
		for _, e := range m.Members {
			l = e.Size()
			n += 1 + l + sovLtsrpc(uint64(l))
		}
	}
	if m.Leader != nil {
		l = m.Leader.Size()
		n += 1 + l + sovLtsrpc(uint64(l))
	}
	if m.EtcdLeader != nil {
		l = m.EtcdLeader.Size()
		n += 1 + l + sovLtsrpc(uint64(l))
	}
	return n
}

func (m *GetTxnTimestampCtx) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TxnId != 0 {
		n += 1 + sovLtsrpc(uint64(m.TxnId))
	}
	if m.TxnTs != 0 {
		n += 1 + sovLtsrpc(uint64(m.TxnTs))
	}
	return n
}

func sovLtsrpc(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozLtsrpc(x uint64) (n int) {
	return sovLtsrpc(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Cluster) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLtsrpc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Cluster: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Cluster: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterId", wireType)
			}
			m.ClusterId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLtsrpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClusterId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipLtsrpc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLtsrpc
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthLtsrpc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Status) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLtsrpc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Status: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Status: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLtsrpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= StatusCode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLtsrpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLtsrpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLtsrpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLtsrpc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLtsrpc
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthLtsrpc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Member) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLtsrpc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Member: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Member: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemberId", wireType)
			}
			m.MemberId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLtsrpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MemberId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLtsrpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLtsrpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLtsrpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeerUrls", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLtsrpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLtsrpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLtsrpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PeerUrls = append(m.PeerUrls, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientUrls", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLtsrpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLtsrpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLtsrpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientUrls = append(m.ClientUrls, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeaderPriority", wireType)
			}
			m.LeaderPriority = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLtsrpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LeaderPriority |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipLtsrpc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLtsrpc
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthLtsrpc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RequestHeader) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLtsrpc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RequestHeader: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RequestHeader: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterId", wireType)
			}
			m.ClusterId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLtsrpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClusterId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipLtsrpc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLtsrpc
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthLtsrpc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResponseHeader) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLtsrpc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResponseHeader: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResponseHeader: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterId", wireType)
			}
			m.ClusterId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLtsrpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClusterId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLtsrpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLtsrpc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLtsrpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &Status{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLtsrpc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLtsrpc
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthLtsrpc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetMembersRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLtsrpc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetMembersRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetMembersRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLtsrpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLtsrpc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLtsrpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Header == nil {
				m.Header = &RequestHeader{}
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLtsrpc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLtsrpc
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthLtsrpc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetMembersResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLtsrpc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetMembersResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetMembersResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLtsrpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLtsrpc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLtsrpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Header == nil {
				m.Header = &ResponseHeader{}
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Members", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLtsrpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLtsrpc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLtsrpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Members = append(m.Members, &Member{})
			if err := m.Members[len(m.Members)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Leader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLtsrpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLtsrpc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLtsrpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Leader == nil {
				m.Leader = &Member{}
			}
			if err := m.Leader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EtcdLeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLtsrpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLtsrpc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLtsrpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EtcdLeader == nil {
				m.EtcdLeader = &Member{}
			}
			if err := m.EtcdLeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLtsrpc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLtsrpc
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthLtsrpc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetTxnTimestampCtx) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLtsrpc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetTxnTimestampCtx: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetTxnTimestampCtx: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxnId", wireType)
			}
			m.TxnId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLtsrpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TxnId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxnTs", wireType)
			}
			m.TxnTs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLtsrpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TxnTs |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipLtsrpc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLtsrpc
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthLtsrpc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipLtsrpc(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowLtsrpc
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowLtsrpc
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowLtsrpc
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthLtsrpc
			}
			iNdEx += length
			if iNdEx < 0 {
				return 0, ErrInvalidLengthLtsrpc
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowLtsrpc
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipLtsrpc(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
				if iNdEx < 0 {
					return 0, ErrInvalidLengthLtsrpc
				}
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthLtsrpc = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowLtsrpc   = fmt.Errorf("proto: integer overflow")
)
