<!-- doc/src/sgml/start.sgml -->

<chapter id="tutorial-start">
<!--
  <title>Getting Started</title>
-->
  <title>さあ始めましょう</title>

  <sect1 id="tutorial-install">
<!--
    <title>Installation</title>
-->
    <title>インストール</title>

    <para>
<!--
      In this section we assume that you have already
	installed <productname>Pgpool-II</productname> following an
	instruction described in <xref linkend="admin">.
	Alternatively you can use <xref linkend="PGPOOL-SETUP"> to
	create a temporary installation
	of <productname>Pgpool-II</productname>
	and <productname>PostgreSQL</productname>.
-->
この節では、<xref linkend="admin">の説明に基づいて、すでに<productname>Pgpool-II</productname>をインストール済みであると見なしています。
他の方法としては、<xref linkend="PGPOOL-SETUP">を使って<productname>Pgpool-II</productname>と<productname>PostgreSQL</productname>を一時的にインストールすることもできます。
    </para>
  </sect1>

  <sect1 id="tutorial-replication">
<!--
    <title>Your First Replication</title>
-->
    <title>はじめてのレプリケーション</title>

    <para>
<!--
      In this section we are going to explain how to manage a
      <productname>PostgreSQL</productname> cluster with streaming
      replication using <productname>Pgpool-II</productname>, which is
      one of most common setup.
-->
この節では、<productname>Pgpool-II</productname>を使って、もっとも一般的な設定の一つである、<productname>PostgreSQL</productname>クラスターをストリーミングレプリケーション構成で管理する方法を説明します。
    </para>

    <para>
<!--
      Before going further, you should properly set
      up <filename>pgpool.conf</filename> with streaming replication
      mode. For this at least
      following two directives must be set:
-->
先に進む前に、ストリーミングレプリケーションモードで<filename>pgpool.conf</filename>を設定しましょう。
このためには、少なくとも次の2つの項目を設定しなければなりません。
      <programlisting>
master_slave_mode = on
master_slave_sub_mode = 'stream'
      </programlisting>
    </para>
    <para>
<!--
      If you plan to use <command>pgpool_setup</command>, type:
-->
<command>pgpool_setup</command>を使うということであれば、次のようにタイプして下さい。
      <programlisting>
pgpool_setup
</programlisting>
<!--
      This will create
      a <productname>Pgpool-II</productname> with streaming
      replication mode installation,
      primary <productname>PostgreSQL</productname> installation, and
      a async standby <productname>PostgreSQL</productname>
      installation.
-->
これにより、ストリーミングレプリケーション設定の<productname>Pgpool-II</productname>、<productname>PostgreSQL</productname>プライマリサーバのインストール、それに<productname>PostgreSQL</productname>の非同期スタンバイのインストールが行われます。
    </para>
    <para>
<!--
      From now on, we assume that you
      use <command>pgpool_setup</command> to create the installation
      under current directory. Please note that the current directory
      must be empty before executing <command>pgpool_setup</command>.
-->
ここからは、<command>pgpool_setup</command>を使ってカレントディレクトリ以下にインストールを行うことを前提とします。
    </para>
    <para>
<!--
      To start the whole system, type:
-->
システム全体を起動するには、次のようにタイプして下さい。
<programlisting>
./startall
</programlisting>
    </para>
    <para>
<!--
      Once the system starts, you can check the cluster status by
      issuing a pseudo SQL command called "show pool_node" to any of
      databases. <command>pgpool_setup</command> automatically creates
      "test" database. We use the database. Note that the port number
      is 11000, which is the default port number assigned
      to <productname>Pgpool-II</productname>
      by <command>pgpool_setup</command>.
-->
システムが起動すれば、任意のデータベースに擬似SQLコマンドの"show pool_node"を発行して、クラスタの状態を確認することができます。
<command>pgpool_setup</command>は、自動的に"test"データベースを作ります。
このデータベースを使います。
<command>pgpool_setup</command>により、<productname>Pgpool-II</productname>にデフォルトポート番号として11000がアサインされていることに注意してください。
      <programlisting>
$ psql -p 11000 -c "show pool_nodes" test
 node_id | hostname | port  | status | lb_weight |  role   | select_cnt | load_balance_node | replication_delay 
---------+----------+-------+--------+-----------+---------+------------+-------------------+-------------------
 0       | /tmp     | 11002 | up     | 0.500000  | primary | 0          | false             | 0
 1       | /tmp     | 11003 | up     | 0.500000  | standby | 0          | true              | 0
(2 rows)
      </programlisting>
<!--
      The result shows that the "status" column is "up", which means
      the
      <productname>PostgreSQL</productname> is up and running, which
      is good.
-->
この結果は、"status"カラムが"up"であることを示しています。
これは、<productname>PostgreSQL</productname>が稼働中で、問題ないということです。
    </para>
  </sect1>

  <sect1 id="tutorial-testing-load-balance">
<!--
    <title>Testing Load Balance</title>
-->
    <title>負荷分散を試してみる</title>
    <para>
<!--
      <productname>Pgpool-II</productname> allows read query load
      balancing. It is enabled by default. To see the effect, let's
      use <command>pgbench -S</command> command.
-->
<productname>Pgpool-II</productname>では、読み込みクエリの負荷分散が可能です。
デフォルトでこの機能は有効です。
その効果を確かめるために、<command>pgbench -S</command>コマンドを使ってみましょう。
      <programlisting>
$ pgbench -p 11000 -c 10 -S -T 10 test
starting vacuum...end.
transaction type: &lt;builtin: select only>
scaling factor: 1
query mode: simple
number of clients: 10
number of threads: 1
duration: 10 s
number of transactions actually processed: 148044
latency average = 0.676 ms
tps = 14802.897506 (including connections establishing)
tps = 14810.213749 (excluding connections establishing)

$ psql -p 11000 -c "show pool_nodes" test
 node_id | hostname | port  | status | lb_weight |  role   | select_cnt | load_balance_node | replication_delay 
---------+----------+-------+--------+-----------+---------+------------+-------------------+-------------------
 0       | /tmp     | 11002 | up     | 0.500000  | primary | 75152      | true              | 0
 1       | /tmp     | 11003 | up     | 0.500000  | standby | 72893      | false             | 0
(2 rows)
      </programlisting>
<!--
      "select_cnt" column shows how many SELECT are dispatched to each
      node. Since with the default
      configuration, <productname>Pgpool-II</productname> tries to
      dispatch equal number of SELECT, the column shows almost same
      numbers.
-->
"select_cnt"カラムは、いくつSELECTが各々のノードに送られたかを示します。
設定がデフォルトで、<productname>Pgpool-II</productname>は同じ数のSELECTを送ろうとするので、そのカラムはほぼ同じ値を示しています。
    </para>
    <para>
<!--
      <productname>Pgpool-II</productname> offers more sophisticated
      strategy for load
      balancing. See <xref linkend="runtime-config-load-balancing">
      for more details.
-->
<productname>Pgpool-II</productname>では、負荷分散の更に洗練された戦略の利用が可能です。
詳細は<xref linkend="runtime-config-load-balancing">をご覧ください。
    </para>
  </sect1>

  <sect1 id="tutorial-testing-replication">
<!--
    <title>Testing Replication</title>
-->
    <title>レプリケーションを試してみる</title>

    <para>
<!--
      Let's test the replication functionality using a benchmark
      tool <command>pgbench</command>, which comes with the
      standard <productname>PostgreSQL</productname> installation.
      Type following to create the benchmark tables.
-->
<productname>PostgreSQL</productname>に同梱されているベンチマークツールの<command>pgbench</command>を使って、レプリケーション機能を試してみましょう。
      <programlisting>
$ pgbench -i -p 11000 test
      </programlisting>
<!--
      To see if the replication works correctly, directly connect to
      the primary and the standby server to see if they return
      identical results.
-->
レプリケーションが正しく動いているかどうか確かめるために、直接プライマリとスタンバイサーバに接続して、両方が同じ結果を返すかどうか見てみます。
      <programlisting>
$ psql -p 11002 test
\dt
              List of relations
 Schema |       Name       | Type  |  Owner  
--------+------------------+-------+---------
 public | pgbench_accounts | table | t-ishii
 public | pgbench_branches | table | t-ishii
 public | pgbench_history  | table | t-ishii
 public | pgbench_tellers  | table | t-ishii
(4 rows)
\q
$ psql -p 11003 test
\dt
              List of relations
 Schema |       Name       | Type  |  Owner  
--------+------------------+-------+---------
 public | pgbench_accounts | table | t-ishii
 public | pgbench_branches | table | t-ishii
 public | pgbench_history  | table | t-ishii
 public | pgbench_tellers  | table | t-ishii
(4 rows)
      </programlisting>
<!--
      The primary server (port 11002) and the standby server (port
      11003) return identical results. Next, let's run pgbench for a
      while and check to results.
-->
プライマリサーバ（ポート11002）とスタンバイサーバ（ポート11003）は、同一の結果を返しています。
次に、pgbenchをしばらく走らせて、結果を見てみます。
      <programlisting>
$ pgbench -p 11000 -T 10 test
starting vacuum...end.
transaction type: &lt;builtin: TPC-B (sort of)&gt;
scaling factor: 1
query mode: simple
number of clients: 1
number of threads: 1
duration: 10 s
number of transactions actually processed: 2171
latency average = 4.692 ms
tps = 213.147520 (including connections establishing)
tps = 213.258008 (excluding connections establishing)

$ psql -p 11002 -c "SELECT sum(abalance) FROM pgbench_accounts" test
  sum   
--------
 192112
(1 row)

$ psql -p 11003 -c "SELECT sum(abalance) FROM pgbench_accounts" test
  sum   
--------
 192112
(1 row)
      </programlisting>
<!--
      Again, the results are identical.
-->
ここでも結果は同じでした。
    </para>
  </sect1>

  <sect1 id="tutorial-testing-failover">
<!--
    <title>Testing Fail Over</title>
-->
    <title>フェイルオーバを試してみる</title>

    <para>
<!--
      <productname>Pgpool-II</productname> allows an automatic fail
      over when <productname>PostgreSQL</productname> server goes
      down. In this case <productname>Pgpool-II</productname> sets the
      status of the server to "down" and continue the database
      operation using remaining servers.
-->
<productname>PostgreSQL</productname>サーバが停止した際に、<productname>Pgpool-II</productname>は自動フェイルオーバさせることができます。
この場合、<productname>Pgpool-II</productname>はステータスを"down"にして、残ったサーバでデータベースの運用を継続します。
      <programlisting>
$ pg_ctl -D data1 stop
waiting for server to shut down.... done
server stopped
$ psql -p 11000 -c "show pool_nodes" test
 node_id | hostname | port  | status | lb_weight |  role   | select_cnt | load_balance_node | replication_delay 
---------+----------+-------+--------+-----------+---------+------------+-------------------+-------------------
 0       | /tmp     | 11002 | up     | 0.500000  | primary | 2172       | true              | 0
 1       | /tmp     | 11003 | down   | 0.500000  | standby | 0          | false             | 0
(2 rows)

$ psql -p 11000 -c "SELECT sum(abalance) FROM pgbench_accounts" test
  sum   
--------
 192112
(1 row)
      </programlisting>
<!--
      The standby node was shut down by pg_ctl
      command. <productname>Pgpool-II</productname> detects it and
      detaches the standby node. "show pool_nodes" command shows that
      the standby node is in down status. You can continue to use the
      cluster without the standby node:
-->
スタンバイノードをpg_ctlコマンドで停止しました。
<productname>Pgpool-II</productname>はそのことを検出し、そのスタンバイノードを切り離します。
"show pool_nodes"コマンドは、スタンバイノードがダウンしていることを表示します。
このスタンバイノードなしで、クラスタの運用を継続できます。
      <programlisting>
$ psql -p 11000 -c "SELECT sum(abalance) FROM pgbench_accounts" test
  sum   
--------
 192112
(1 row)
      </programlisting>
<!--
      What happens if the primary server goes down? In this case, one
      of remaining standby server is promoted to new primary
      server. For this testing, we start from the state in which both
      nodes are up.
-->
プライマリサーバが落ちたらどうなるでしょう？
この場合、残ったスタンバイサーバの一つが新しいプライマリサーバへと昇格します。
テストのため、両方のノードが稼働中である状態から始めます。
      <programlisting>
$ psql -p 11000 -c "show pool_nodes" test
 node_id | hostname | port  | status | lb_weight |  role   | select_cnt | load_balance_node | replication_delay 
---------+----------+-------+--------+-----------+---------+------------+-------------------+-------------------
 0       | /tmp     | 11002 | up     | 0.500000  | primary | 2173       | true              | 0
 1       | /tmp     | 11003 | up     | 0.500000  | standby | 0          | false             | 0
(2 rows)

$ pg_ctl -D data0 stop
waiting for server to shut down.... done
server stopped
$ psql -p 11000 -c "show pool_nodes" test
 node_id | hostname | port  | status | lb_weight |  role   | select_cnt | load_balance_node | replication_delay 
---------+----------+-------+--------+-----------+---------+------------+-------------------+-------------------
 0       | /tmp     | 11002 | down   | 0.500000  | standby | 2173       | false             | 0
 1       | /tmp     | 11003 | up     | 0.500000  | primary | 0          | true              | 0
(2 rows)
      </programlisting>
<!--
      Now the primary node is changed from 0 to 1. What happens
      inside? When the node 0 goes
      down, <productname>Pgpool-II</productname> detects it and
      executes "fail_over_script" defined
      in <filename>pgpool.conf</filename>.  Here is the content of the
      file.
-->
プライマリノードが0から1へと変わりました。
内部では何が起きたのでしょう？
ノード0がダウンした時、<productname>Pgpool-II</productname>はそのことを検出し、<filename>pgpool.conf</filename>に定義された"fail_over_script"を実行します。
その内容を以下に示します。
      <programlisting>
#! /bin/sh
# Execute command by failover.
# special values:  %d = node id
#                  %h = host name
#                  %p = port number
#                  %D = database cluster path
#                  %m = new master node id
#                  %M = old master node id
#                  %H = new master node host name
#                  %P = old primary node id
#                  %R = new master database cluster path
#                  %r = new master port number
#                  %% = '%' character
failed_node_id=$1
failed_host_name=$2
failed_port=$3
failed_db_cluster=$4
new_master_id=$5
old_master_id=$6
new_master_host_name=$7
old_primary_node_id=$8
new_master_port_number=$9
new_master_db_cluster=${10}
mydir=/home/t-ishii/tmp/Tutorial
log=$mydir/log/failover.log
pg_ctl=/usr/local/pgsql/bin/pg_ctl
cluster0=$mydir/data0
cluster1=$mydir/data1

date >> $log
echo "failed_node_id $failed_node_id failed_host_name $failed_host_name failed_port $failed_port failed_db_cluster $failed_db_cluster new_master_id $new_master_id old_master_id $old_master_id new_master_host_name $new_master_host_name old_primary_node_id $old_primary_node_id new_master_port_number $new_master_port_number new_master_db_cluster $new_master_db_cluster" >> $log

if [ a"$failed_node_id" = a"$old_primary_node_id" ];then	# master failed
! 	new_primary_db_cluster=${mydir}/data"$new_master_id"
	echo $pg_ctl -D $new_primary_db_cluster promote >>$log	# let standby take over
	$pg_ctl -D $new_primary_db_cluster promote >>$log	# let standby take over
fi
      </programlisting>
<!--
      The script receives necessary information as parameters
      from <productname>Pgpool-II</productname>. If the primary server
      goes down, it executes "pg_ctl -D data1 promote", which should
      promote the standby server to a new primary server.
-->
そのスクリプトは、パラメータとして必要な情報を<productname>Pgpool-II</productname>から受け取ります。
プライマリサーバが落ちた時に、"pg_ctl -D data1 promote"を実行し、スタンバイサーバは新しいプライマリサーバへと昇格します。
    </para>
  </sect1>

  <sect1 id="tutorial-testing-online-recovery">
<!--
    <title>Testing Online Recovery</title>
-->
    <title>オンラインリカバリを試してみる</title>
    <para>
<!--
      <productname>Pgpool-II</productname> allows to recover a downed
      node by technique called "Online Recovery". This copies data
      from the primary node to a standby node so that it sync with the
      primary. This may take long time and database may be updated
      during the process. That's no problem because in the streaming
      configuration, the standby will receive WAL log and applies it
      to catch up the primary. To test online recovery, let's start
      with previous cluster, where node 0 is in down state.
-->
<productname>Pgpool-II</productname>は、「オンラインリカバリ」という技術を使ってダウンしたノードを復旧させることができます。
これはプライマリノードからデータをスタンバイノードへとコピーし、プライマリと同期させます。
それには長い時間がかかることがあり、その間にデータが更新されるかもしれません。
これは問題になりません。なぜなら、ストリーミングレプリケーション構成では、スタンバイはWALログを受け取り、それを適用することによってプライマリに追い付くことができるからです。
オンラインリカバリをテストするために、ノード0が落ちている先ほどのクラスタから始めましょう。
      <programlisting>
$ pcp_recovery_node -p 11001 0
Password: 
pcp_recovery_node -- Command Successful

$ psql -p 11000 -c "show pool_nodes" test
 node_id | hostname | port  | status | lb_weight |  role   | select_cnt | load_balance_node | replication_delay 
---------+----------+-------+--------+-----------+---------+------------+-------------------+-------------------
 0       | /tmp     | 11002 | up     | 0.500000  | standby | 2173       | true              | 0
 1       | /tmp     | 11003 | up     | 0.500000  | primary | 0          | false             | 0
(2 rows)
      </programlisting>
<!--
      <xref linkend="pcp-recovery-node"> is one of control commands
      coming with <productname>Pgpool-II</productname>
      installation. The argument -p is to specify the port number
      assigned to the command, which is 11001 set
      by <command>pgpool_setup</command>. The second argument is the
      target node id. After executing the command, node 0 returned to
      "up" status.
-->
<xref linkend="pcp-recovery-node">は、インストールされた<productname>Pgpool-II</productname>に含まれる管理コマンドの一つです。
引数の-pは、コマンドにアサインされたポート番号です。
<command>pgpool_setup</command>は11001に設定しています。
次の引数はターゲットになるノードIDです。
コマンドを実行すると、ノード0は"up"状態に復帰します。
    </para>
    <para>
<!--
      The script executed by <command>pcp_recovery_node</command> is
      specified as "recovery_1st_stage_command"
      in <filename>pgpool.conf</filename>. Here is the file installed
      by <command>pgpool_setup</command>.
-->
<command>pcp_recovery_node</command>が実行するスクリプトは、<filename>pgpool.conf</filename>で"recovery_1st_stage_command"として指定されています。
<command>pgpool_setup</command>がインストールするファイルはこれです。
      <programlisting>
#! /bin/sh
psql=/usr/local/pgsql/bin/psql
DATADIR_BASE=/home/t-ishii/tmp/Tutorial
PGSUPERUSER=t-ishii

master_db_cluster=$1
recovery_node_host_name=$2
DEST_CLUSTER=$3
PORT=$4

log=$DATADIR_BASE/log/recovery.log

$psql -p $PORT -c "SELECT pg_start_backup('Streaming Replication', true)" postgres

echo "source: $master_db_cluster dest: $DEST_CLUSTER" > $log

rsync -C -a -c --delete --exclude postgresql.conf --exclude postmaster.pid \
--exclude postmaster.opts --exclude pg_log \
--exclude recovery.conf --exclude recovery.done \
--exclude pg_xlog \
$master_db_cluster/ $DEST_CLUSTER/

rm -fr $DEST_CLUSTER/pg_xlog 
mkdir $DEST_CLUSTER/pg_xlog
chmod 700 $DEST_CLUSTER/pg_xlog
rm $DEST_CLUSTER/recovery.done
cat > $DEST_CLUSTER/recovery.conf $lt;$lt;REOF
standby_mode          = 'on'
primary_conninfo      = 'port=$PORT user=$PGSUPERUSER'
recovery_target_timeline='latest'
REOF

$psql -p $PORT -c "SELECT pg_stop_backup()" postgres
      </programlisting>
    </para>
  </sect1>

  <sect1 id="tutorial-arch">
<!--
    <title>Architectural Fundamentals</title>
-->
    <title>基礎的な構造</title>

    <para>
<!--
      <productname>Pgpool-II</productname> is a proxy server sitting
      between clients and <productname>PostgreSQL</productname>.
      <productname>Pgpool-II</productname> understands the wire level
      protocol used by <productname>PostgreSQL</productname> called
      "frontend and backend protocol". For more details of the
      protocol, see the <productname>PostgreSQL</productname> manual.
      No modified <productname>PostgreSQL</productname> is required to
      use <productname>Pgpool-II</productname> (more precisely, you
      will need a few extensions to use full functions
      of <productname>Pgpool-II</productname>). So <productname>Pgpool-II</productname>
      can cope with variety of <productname>PostgreSQL</productname>
      versions. In theory, even the earliest version
      of <productname>PostgreSQL</productname> can be used
      with <productname>Pgpool-II</productname>. Same thing can be
      said to client side. As long as it follows the
      protocol, <productname>Pgpool-II</productname> happily accept
      connections from it, no matter what kind of languages or drivers
      it uses.
-->
<productname>Pgpool-II</productname>は、クライアントと<productname>PostgreSQL</productname>の間に位置するproxyサーバです。
<productname>Pgpool-II</productname>は、"frontend and backend protocol"と呼ばれるネットワーク上のプロトコルを理解します。
プロトコルの詳細については、<productname>PostgreSQL</productname>のマニュアルをご覧ください。
<productname>Pgpool-II</productname>を利用するにあたって、<productname>PostgreSQL</productname>を変更する必要はありません。
（正確には、<productname>Pgpool-II</productname>のすべての機能を使うためには、少数の拡張をインストールする必要があります）
したがって、<productname>Pgpool-II</productname>は色々なバージョンの<productname>PostgreSQL</productname>と協調することができます。
理論的には、最初期のバージョンの<productname>PostgreSQL</productname>さえ、<productname>Pgpool-II</productname>で使用できます。
クライアント側についても同じことが言えます。
プロトコルに従う限り、どのような言語やドライバを使おうと、<productname>Pgpool-II</productname>は問題なく接続を受け付けます。
    </para>
    <para>
<!--
      <productname>Pgpool-II</productname> consists of multiple
      process. There is a main process, which is the parent process of
      all other process. It is responsible for forking child process
      each of which accepts connections from clients. There are some
      worker process those are forked from the main process as well,
      which is responsible for detecting streaming replication
      delay. There is also a special process called "pcp process",
      which is solely used for management
      of <productname>Pgpool-II</productname>
      itself. <productname>Pgpool-II</productname> has a built-in high
      availability function called "watchdog". Watchdog consists of
      some process. For more details of watchdog,
      see <xref linkend="tutorial-watchdog">.
-->
<productname>Pgpool-II</productname>は複数のプロセスから構成されます。
他のすべてのプロセスの親となるメインプロセスがあります。
メインプロセスは、クライアントからのコネクションを受け付ける子プロセスをforkする役割があります。
また、メインプロセスからforkされるいくつかのワーカープロセスがあります。
ワーカープロセスは、ストリーミングレプリケーションの遅延を検出する役目があります。
また、「PCPCプロセス」と呼ばれる特殊なプロセスがあります。これは、<productname>Pgpool-II</productname>の管理専用に使用されます。
<productname>Pgpool-II</productname>には、組み込みの"watchdog"と呼ばれる組み込みの高可用性機能があります。
watchdogはいくつかのプロセスから構成されています。
watchdogの詳細については<xref linkend="tutorial-watchdog">をご覧ください。
    </para>
    <para>
      <figure>
<!--
	<title>Process architecure of <productname>Pgpool-II</productname></title>
-->
	<title><productname>Pgpool-II</productname>のプロセス構造</title>
	<mediaobject>
	  <imageobject>
	    <imagedata fileref="process-diagram.gif">
	  </imageobject>
	</mediaobject>
      </figure>
    </para>

  </sect1>

</chapter>
