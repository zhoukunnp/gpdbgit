<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>制限事項</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK
REV="MADE"
HREF="mailto:pgsql-docs@postgresql.org"><LINK
REL="HOME"
TITLE="Pgpool-II 3.6.4 文書"
HREF="index.html"><LINK
REL="UP"
TITLE="はじめに"
HREF="preface.html"><LINK
REL="PREVIOUS"
TITLE="更なる情報"
HREF="resources.html"><LINK
REL="NEXT"
TITLE="バグ報告の指針"
HREF="bug-reporting.html"><LINK
REL="STYLESHEET"
TYPE="text/css"
HREF="stylesheet.css"><META
HTTP-EQUIV="Content-Type"
CONTENT="text/html; charset=utf-8"><META
NAME="creation"
CONTENT="2017-05-11T10:04:34"></HEAD
><BODY
CLASS="SECT1"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="4"
ALIGN="center"
VALIGN="bottom"
><A
HREF="index.html"
>Pgpool-II 3.6.4 文書</A
></TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
TITLE="更なる情報"
HREF="resources.html"
ACCESSKEY="P"
>前のページ</A
></TD
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
HREF="preface.html"
ACCESSKEY="U"
>上に戻る</A
></TD
><TD
WIDTH="60%"
ALIGN="center"
VALIGN="bottom"
>はじめに</TD
><TD
WIDTH="20%"
ALIGN="right"
VALIGN="top"
><A
TITLE="バグ報告の指針"
HREF="bug-reporting.html"
ACCESSKEY="N"
>次のページ</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="RESTRICTIONS"
>制限事項</A
></H1
><P
>この章では、<SPAN
CLASS="PRODUCTNAME"
>Pgpool-II</SPAN
>の現在の制限事項について説明します。

  <P
></P
></P><DIV
CLASS="VARIABLELIST"
><DL
><DT
>PostgreSQLの機能</DT
><DD
><P
><CODE
CLASS="FUNCTION"
>pg_terminate_backend()</CODE
>を使ってバックエンドを停止すると、フェイルオーバが起こります。
これは、<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>が、postmasterの停止と全く同じメッセージをバックエンド停止時に送るためです。
3.6より前のバージョンには回避策はありません。
3.6以降では、この制限は緩和されています。
その関数の引数（プロセスIDです）が定数なら、その関数を使っても安全です。
しかし、拡張プロトコルでは、その関数は使えません。
     </P
></DD
><DT
>認証/アクセス制御</DT
><DD
><P
>レプリケーションモードまたマスタ/スレーブモード時にはtrust、reject、clear text password、pam認証方式が利用できます。
crypt認証は利用できません。
<SPAN
CLASS="PRODUCTNAME"
>Pgpool-II</SPAN
> 3.0以降では、<TT
CLASS="FILENAME"
>pool_passwd</TT
>というファイルを使ってmd5認証も使えます。
<TT
CLASS="FILENAME"
>pool_passwd</TT
>はデフォルトの認証ファイル名です。
md5認証を有効にする手順を示します。
      </P
><P
></P
><OL
TYPE="1"
><LI
><P
>DBユーザのOSアカウントでログインし、以下を実行します。
	    </P><PRE
CLASS="PROGRAMLISTING"
>            pg_md5 --md5auth --username=<TT
CLASS="LITERAL"
>your_username</TT
> <TT
CLASS="LITERAL"
>your_passwd</TT
>
	    </PRE
><P>
&#62;md5により暗号化されたユーザ名とパスワードがpool_passwdに登録されます。
pool_passwdがまだ存在しなければ、pg_md5コマンドは、自動的にpgpool.confと同じディレクトリ内にpool_passwdwを作成します。
pool_passwdのフォーマットは、<TT
CLASS="LITERAL"
>username:encrypted_passwd</TT
>です。
	  </P
></LI
><LI
><P
>また、pool_hba.confに適当なmd5のエントリを作成する必要があります。
詳細は<A
HREF="auth-pool-hba-conf.html"
>項6.1</A
>を見てください。
	  </P
></LI
><LI
><P
>pool_passwdに登録するパスワードは、<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>に登録したパスワードと完全に同じでなければなりません。
	  </P
></LI
><LI
><P
>md5パスワード（もちろんpool_passwdとPostgreSQLの両方）を変更したら、pgpool reload を実行してください。
	  </P
></LI
></OL
></DD
><DT
>ラージオブジェクト</DT
><DD
><P
>ストリーミングレプリケーションモードでは、<SPAN
CLASS="PRODUCTNAME"
>Pgpool-II</SPAN
>はラージオブジェクトをサポートしています。
      </P
><P
>ネィティブレプリケーションモードでは、<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> 8.1以降ならばラージオブジェクトをサポートします。
その際には、<TT
CLASS="FILENAME"
>pgpool.conf</TT
>のlobj_lock_tableを有効にしてください。
なお、バックエンド関数の<CODE
CLASS="FUNCTION"
>lo_import</CODE
>を使ったラージオブジェクトのレプリケーションはサポートされていません。
      </P
><P
>Slonyモードも含め、その他のモードではラージオブジェクトはサポートされていません。
      </P
></DD
><DT
>一時テーブル</DT
><DD
><P
>一時テーブルの作成、挿入、更新、削除は、常にマスター（プライマリ）で実行されます。
テーブルに対するSELECTもマスター上で実行されます。
しかし、一時テーブル名が文字列としてSELECTで使われると、それを検知する方法がないため、SELECTは負荷分散されます。
これにより、「テーブルが見つからない」エラーになったり、同じ名前を持つ別のテーブルを検索することになります。
この問題を回避するには、/*NO LOAD BALANCE*/ SQLコメントを使ってください。
      </P
><P
>ちなみに、psqlの\dコマンドのように、システムカタログを問い合わせる中で
文字列としてのテーブル名を使っている場合:
	</P><PRE
CLASS="PROGRAMLISTING"
>SELECT 't1'::regclass::oid;
	</PRE
><P>
pgpool-II 3.0以降ではマスタで検索が行なわれるので、問題になりません。
なぜなら、システムカタログへの検索は常にマスタで行なわれるからです。
      </P
><P
>PostgreSQL 8.3以後を使っているのであれば、<TT
CLASS="COMMAND"
>CREATE TEMP TABLE</TT
>によって作成されたテーブルは、reset_query_list中のDISCARD ALLを指定することによってセッションの最後で削除されます。
      </P
><P
>8.2.x以前では、<TT
CLASS="COMMAND"
>CREATE TEMP TABLE</TT
>によって作成されたテーブルは、セッションを終了した後に削除されません。
PostgreSQLバックエンドから見ると、コネクションプールによってセッションが維持されているからです。
これを回避するには、明示的に<TT
CLASS="COMMAND"
>DROP TABLE</TT
>を発行するか、トランザクションブロックの内側で<TT
CLASS="COMMAND"
>CREATE TEMP TABLE ... ON COMMIT DROP</TT
>を実施します。
      </P
></DD
><DT
>ネィティブレプリケーションモードにおける関数などの扱い</DT
><DD
><P
>文脈依存の仕組み（たとえば乱数やトランザクションID、OID、SERIAL、シーケンス）を使って提供されるデータが複数のバックエンドに正しくレプリケーションされる保証はありません。
SERIALに対しては、insert_lockを使って対応できます。
SELECT setval()とSELECT nextval()に対してもinsert_lockで対応できます。
      </P
><P
><CODE
CLASS="FUNCTION"
>CURRENT_TIMESTAMP</CODE
>、<CODE
CLASS="FUNCTION"
>CURRENT_DATE</CODE
>、<CODE
CLASS="FUNCTION"
>now()</CODE
>を含むINSERT/UPDATEは正しくレプリケーションされます。
<CODE
CLASS="FUNCTION"
>CURRENT_TIMESTAMP</CODE
>、<CODE
CLASS="FUNCTION"
>CURRENT_DATE</CODE
>、<CODE
CLASS="FUNCTION"
>now()</CODE
>をデフォルト値として使うINSERT/UPDATEも正しくレプリケーションされます。
これは、関数を、クエリ実行時にマスターから取得した定数に置き換えることで達成されています。
しかし、いくつか制限事項があります。
      </P
><P
><SPAN
CLASS="PRODUCTNAME"
>Pgpool-II</SPAN
> 3.0以前では、テーブルのデフォルト値としての時制データが正しく計算されない場合があります。
例として以下のテーブル定義を示します。
	</P><PRE
CLASS="PROGRAMLISTING"
>CREATE TABLE rel1(
  d1 date DEFAULT CURRENT_DATE + 1
)
	</PRE
><P>
これは次と同じに扱われます。
	</P><PRE
CLASS="PROGRAMLISTING"
>CREATE TABLE rel1(
  d1 date DEFAULT CURRENT_DATE
)
	</PRE
><P>
<SPAN
CLASS="PRODUCTNAME"
>Pgpool-II</SPAN
> 3.1以降はこのケースを正しく扱います。
ですのでd1列はtomorrowがデフォルト値になります。
しかし、この改善は拡張プロトコル（たとえばJDBC、PHP PDO）やPREPAREが使用されている場合には適用されません。
      </P
><P
>列の型が時制ではない場合は書き換えは行われないことに注意してください。
そのような例を示します。
	</P><PRE
CLASS="PROGRAMLISTING"
>foo bigint default (date_part('epoch'::text,('now'::text)::timestamp(3) with time zone) * (1000)::double precision)
	</PRE
><P>
以下のテーブルがあるとします。
	</P><PRE
CLASS="PROGRAMLISTING"
>CREATE TABLE rel1(
  c1 int,
  c2 timestamp default now()
)
	</PRE
><P>
	</P><PRE
CLASS="PROGRAMLISTING"
>INSERT INTO rel1(c1) VALUES(1)
	</PRE
><P>
これは以下に書き換えられるものの、
	</P><PRE
CLASS="PROGRAMLISTING"
>INSERT INTO rel1(c1, c2) VALUES(1, '2009-01-01 23:59:59.123456+09')
	</PRE
><P>
	</P><PRE
CLASS="PROGRAMLISTING"
>INSERT INTO rel1(c1) SELECT 1
	</PRE
><P>
は変換されません。
ですので現在の実装では正しくレプリケーションされません。
値は挿入されますが、全く変換が行われません。
      </P
></DD
><DT
>SQL型コマンド</DT
><DD
><P
><A
HREF="sql-commands.html"
>SQL型コマンド</A
>は、拡張クエリモードでは使用できません。
      </P
></DD
></DL
></DIV
><P>
 </P
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="resources.html"
ACCESSKEY="P"
>前のページ</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>ホーム</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="bug-reporting.html"
ACCESSKEY="N"
>次のページ</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>更なる情報</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="preface.html"
ACCESSKEY="U"
>上に戻る</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>バグ報告の指針</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>